package com.airbnb.mvrx.mock

/**
 * This looks for classes generated via AutoValue, indicated by the class prefix [GENERATED_PREFIX].
 * When an autovalue class is found, code to reconstruct it is generated by reflectively
 * accessing the Builder, seeing which func
 */
class AutoValueTypePrinter : TypePrinter<Any> {

    override fun acceptsObject(obj: Any): Boolean {
        return obj::class.java.simpleName.startsWith(GENERATED_PREFIX)
    }

    override fun generateCode(instance: Any, generateConstructor: (Any?) -> String): String {
        val kClass = this::class
        val name = kClass.simpleName?.substringAfter("_") ?: return "error with autovalue"

        // The builder annotation is not kept at runtime, so to find the builder class we
        // look for teh generated "Builder" nested class.
        val builderClass = kClass.java.classes.firstOrNull { it.simpleName == "Builder" }
            ?: return "Could not find AutoValue Builder for ${instance::class.java.simpleName}"

        val builderMethods = builderClass.declaredMethods
            // We expect all builder methods that set a property to return
            // the builder type. This helps exclude the "build" function.
            .filter { it.returnType.isAssignableFrom(builderClass) }
            .mapNotNull { builderMethod ->
                val valueConstructor =
                    kClass.java.declaredMethods // Methods may be public, protected, or package private
                        .firstOrNull { getter ->
                            getter.name == builderMethod.name ||
                                    getter.name.substringAfter("get") == builderMethod.name.substringAfter(
                                "set"
                            )
                        }
                        ?.invoke(this)
                        ?.let { generateConstructor(it) }
                        ?: return@mapNotNull null

                "\n.${builderMethod.name}($valueConstructor)"
            }.joinToString(separator = "")

        return "$name.builder()$builderMethods\n.build()"
    }

    override fun modifyImports(imports: List<String>): List<String> {
        // At runtime we use the generated autovalue subclass, but our import should actually reference the base class
        return imports.map { it.replace(GENERATED_PREFIX, "") }
    }

    companion object {
        private const val GENERATED_PREFIX = "AutoValue_"
    }
}